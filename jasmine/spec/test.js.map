{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///webpack/bootstrap c70d036083db318b4cf8?72a6","webpack:///./src/inverted-index.js?e055","webpack:///./src/utils.js?2ff8","webpack:///./jasmine/spec/inverted-index-test.js","webpack:///./jasmine/spec/dummy-data/file1.js","webpack:///./jasmine/spec/dummy-data/empty.json","webpack:///./jasmine/spec/dummy-data/file5.json","webpack:///./jasmine/spec/dummy-data/file4.json","webpack:///./jasmine/spec/dummy-data/file3.json"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,QAAQ;AACtB,eAAc,SAAS;AACvB,eAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,SAAS;AACvB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,cAAc,GAAG,aAAa;AACzE;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc,SAAS;AACvB,eAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,SAAS;AACvB,eAAc,SAAS;AACvB,eAAc,WAAW;AACzB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,SAAS;AACvB,eAAc,UAAU;AACxB,eAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;AC3IA;;AAEA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,OAAO;AACvB,iBAAgB,OAAO;AACvB,iBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,iBAAgB,SAAS;AACzB,iBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,QAAQ;AACtB,eAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,EAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;;;AAGH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,EAAC;;;;;;;AC7ND;AACA;AACA;AACA,EAAC;AACD;AACA;AACA,EAAC;;AAED;;;;;;;ACRA;AACA;;;;;;;ACDA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;;;;;;ACVD;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;;;;;;ACXD;AACA;AACA;AACA,EAAC;AACD;AACA;AACA,EAAC;AACD;AACA;AACA,EAAC","file":"test.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"invertedIndex\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"invertedIndex\"] = factory();\n\telse\n\t\troot[\"invertedIndex\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c70d036083db318b4cf8","var utils = require('./utils.js');\n\n/**\n * A class for Creating and searching an inverted index\n */\nclass Index {\n\n  /**\n   * [constructor Creates Object variables to hold\n   * 1. [jsonDatabase] Uploaded files\n   * 2. [indexFile] the indexed filenames and their contents\n   * 3. [searchResult] the search results\n   * @return {[type]} [description]\n   */\n  constructor() {\n    this.jsonDatabase = {};\n    this.indexFile = {};\n    this.searchResult = {};\n    this.indexView = '';\n  }\n\n  /**\n   * [saveUploads creates a key and value object item that stores the uploaded file(s)]\n   * @param  {[string} fileName [filename]\n   * @param  {[object]} jsonFile [content of uploaded json file]\n   * @return {boolean} [returns true on succesful addition of object to datatbase]\n   */\n  saveUploads(fileName, jsonFile) {\n    if (!utils.isValid(fileName, jsonFile)) {\n      return false;\n    }\n    if (typeof jsonFile === 'string') {\n      jsonFile = JSON.parse(jsonFile);\n    }\n    this.jsonDatabase[fileName] = [];\n    Object.keys(jsonFile).forEach((keys) => {\n      this.jsonDatabase[fileName].push(jsonFile[keys]);\n    });\n    return true;\n  }\n\n  /**\n   * [getJsonDatabase function to return the saved uploads]\n   * @return {[object]} [the saved uploads]\n   */\n  getJsonDatabase() {\n    return this.jsonDatabase;\n  }\n\n  /**\n   * [createIndex Creates an index of the words in the received json file]\n   * @param  {string}   filePath [the key(filename) of the json value to index]\n   * @param  {Function} cb  [call back to return the indexed file object/an html format index table]\n   * @return {array} [an arrray of the indexed file result and the html Div of the index]\n   */\n  createIndex(filePath) {\n    const indexFile = this.indexFile;\n    const jsonDoc = this.jsonDatabase[filePath];\n    let concSentence = '';\n    let wordArray = [];\n    if (indexFile[filePath]) {\n      return false;\n    }\n    indexFile[filePath] = {};\n    jsonDoc.forEach((element, index) => {\n      concSentence = utils.cleanString((`${element.title} ${element.text}`));\n      wordArray = new Set(concSentence.split(' '));\n      wordArray.forEach((word) => {\n        indexFile[filePath][word] = indexFile[filePath][word] || [];\n        indexFile[filePath][word].push(index);\n      });\n    });\n    this.indexFile = indexFile;\n    return indexFile[filePath];\n  }\n\n  /**\n   * [getIndex Gets the index object of the indexed json file]\n   * @param  {string} fileName [the filename(key) of the index needed]\n   * @return {[object]}          [index of the object]\n   */\n  getIndex(fileName) {\n    return this.indexFile[fileName] || this.indexFile;\n  }\n\n  /**\n   * [searchIndex It searches the already indexed files for particular words]\n   * @param  {string}    fileNames     [description]\n   * @param  {Function}  cb            [description]\n   * @param  {...[Array]} searchContent [the words to search for]\n   * @return {[Array]}                  [an array of two elements, an\n   * object with the search term as key and their locations in the\n   * array of the originally uploaded file, an html view of the result]\n   */\n  searchIndex(fileNames, ...searchContent) {\n    const searchResult = {};\n    let searchTerms = searchContent.join(' ');\n    if (fileNames.length < 1) {\n      fileNames = this.getFilenames();\n    }\n    searchTerms = utils.cleanString(searchTerms, /[^a-z0-9\\s,]+/gi);\n    searchTerms = searchTerms.split(/[,\\s]/);\n    searchTerms.forEach((searchTerm) => {\n      searchResult[searchTerm] = {};\n      fileNames.forEach((fileName) => {\n        if (this.indexFile[fileName][searchTerm]) {\n          searchResult[searchTerm][fileName] = this.indexFile[fileName][searchTerm];\n        }\n      });\n    });\n    this.searchResult = searchResult;\n    return searchResult;\n    // return cb(searchResult, this.jsonDatabase);\n  }\n\n  /**\n   * [getFilenames returns the filenames of all files present in the object]\n   * @return {array} [an array of filenames]\n   */\n  getFilenames() {\n    return Object.keys(this.jsonDatabase);\n  }\n\n  /**\n   * [deleteIndex Deletes an index file from the index object]\n   * @param  {string} fileName [the filename(key) of the data to delete]\n   * @param  {boolean} option   [determines if to delete the index only or also the json file]\n   * @return {boolean}  [true to delete indexFile and jsonDatabase/false to delete only the index]\n   */\n  deleteIndex(fileName, option) {\n    delete this.indexFile[fileName];\n    if (option === true) {\n      delete this.jsonDatabase[fileName];\n      return true;\n    }\n    return false;\n  }\n\n}\n\nmodule.exports = Index;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/inverted-index.js\n// module id = 3\n// module chunks = 0 1","\nclass util {\n\n  /**\n     * [parseJSON converts sting to a Json object]\n     * @param  {string} jsonFile\n     * @return {object || boolean}  [the parsed file or false on error]\n     */\n  parseJSON(jsonFile) {\n    if (typeof jsonFile === 'object') {\n      return jsonFile;\n    }\n    try {\n      return JSON.parse(jsonFile);\n    } catch (err) {\n      return true;\n    }\n  }\n\n  /**\n     * [isValid Check if a file is a valid json object based, calls method to check structure]\n     * @param  {string}  fileName [the filename to verfity if is the object in the database]\n     * @param  {object}  jsonFile [the json object to be tested]\n     * @return {Boolean}          [returns true if valid else false]\n     */\n  isValid(fileName, jsonFile) {\n    if (typeof jsonFile === 'string') {\n      jsonFile = JSON.parse(jsonFile);\n    }\n    if (jsonFile && jsonFile.length > 0) {\n      const isValidFileStructure = this.checkFileStructure(jsonFile);\n      if (isValidFileStructure) {\n        // if (!this.jsonDatabase[fileName]) {\n        return true;\n        // }\n      }\n    }\n    return false;\n  }\n\n\n  /**\n     * [checkFileStructure Checks if object follows the structure as found in ./jasmine/books.json]\n     * @param  {[object]} jsonFile [json file to be tested]\n     * @return {boolean}          [true if valid and false if invalid]\n     */\n  checkFileStructure(jsonFile) {\n    this.isValidFile = true;\n    jsonFile.forEach((document) => {\n      const isValidTitle = document.title && document.title.length > 0 && typeof document.title === 'string';\n      const isValidText = document.text && document.text.length > 0 && typeof document.text === 'string';\n      if (!(isValidText && isValidTitle)) {\n        this.isValidFile = false;\n        return false;\n      }\n    });\n    return this.isValidFile;\n  }\n\n  /**\n   * [cleanString This method takes in a string with whitespaces, non-alphanumric characters and\n   * Returns a clean version with all unecessary characters striped away]\n   * @param  {string} theString [the string to cleanup]\n   * @param  {[Regex]} theRegex  [the regex to use]\n   * @return {[String]}           [A string Strpped based on the regex]\n   */\n  cleanString(theString, theRegex) {\n    return theString.replace(theRegex, '').toLowerCase() || theString.replace(/[^a-z0-9\\s]+/gi, '').toLowerCase();\n  }\n}\nmodule.exports = new util();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 4\n// module chunks = 0 1","const valid2 = require('./dummy-data/file1.js');\nconst empty = require('./dummy-data/empty.json');\nconst valid1 = require('./dummy-data/file1.js');\nconst invalidStructure = require('./dummy-data/file5.json');\nconst invalidContent = require('./dummy-data/file4.json');\nconst nonString = require('./dummy-data/file3.json');\nvar Index = require('../../src/inverted-index.js');\n\n// /** @type {String} [description] -------------------------------------------------------------- */\n// const invalid = '';\n// const empty = {};\n// const valid1 = [{\n//   title: 'Alice in Wonderland',\n//   text: 'Alice falls into a rabbit hole and enters a world full of imagination.'\n// }, {\n//   title: 'The Lord of the Rings: The Fellowship of the Ring.',\n//   text: 'An unusual alliance of man, elf, dwarf, wizard and hobbit seek to destroy a powerful ring.'\n// }];\n// const valid2 = [{\n//   title: 'Alice in Wonderland',\n//   text: 'Alice falls into a rabbit hole and enters a world full of imagination.'\n// }, {\n//   title: 'The Lord of the Rings: The Fellowship of the Ring.',\n//   text: 'An unusual alliance of man, elf, dwarf, wizard and hobbit seek to destroy a powerful ring.'\n// }];\n// const nonString = [{\n//   title: 'Black Panther',\n//   text: 2\n// }, {\n//   title: 'Constantine: HellBlazer',\n//   text: 'One man stands between Heaven and Hell. He may be our last hope'\n// }, {\n//   title: 'Batman: Year One',\n//   text: 'A rookie BatMan, Fresh from the League of Assasins tries to find his way'\n// }];\n//\n// const invalidContent = [{\n//   title: 'Black Panther',\n//   text: ''\n// }, {\n//   title: 'Constantine: HellBlazer',\n//   text: 'One man stands between Heaven and Hell. He may be our last hope'\n// }, {\n//   title: 'Batman: Year One',\n//   text: 'A rookie BatMan, Fresh from the League of Assasins tries to find his way'\n// }];\n//\n// const invalidStructure = [{\n//   'not-title': 'Black Panther'\n// }, {\n//   title: 'Constantine: HellBlazer',\n//   text: 'One man stands between Heaven and Hell. He may be our last hope'\n// }, {\n//   title: 'Batman: Year One',\n//   text: 'A rookie BatMan, Fresh from the League of Assasins tries to find his way'\n// }];\n// /**\n//  * Dummy Data for Test End --------------------------------------------------------------\n//  */\n\nfunction getFile(filename, cb) {\n  const theResult = [filename];\n  cb(theResult);\n}\ndescribe('Read Book data', function() {\n  const index = new Index();\n  describe('When I upload a JSON file', () => {\n    it('It should checks if its a valid JSON array', (done) => {\n      expect(index.saveUploads('invalidStructure.json', invalidStructure)).toBeFalsy();\n      done();\n    });\n    it('It should check if the file is empty', (done) => {\n      expect(index.saveUploads('empty.json', empty)).toBeFalsy();\n      done();\n    });\n    it('It should check if Its property values are strings', (done) => {\n      expect(index.saveUploads('nonString.json', nonString)).toBeFalsy();\n      done();\n    });\n    it('get json database should return the saved content', (done) => {\n      index.saveUploads('valid1.json', valid1);\n      expect(Object.keys(index.getJsonDatabase()).length).toEqual(1);\n      done();\n    });\n    it('getfilename should return the filenames of the saved contents', (done) => {\n      index.saveUploads('valid1.json', valid1);\n      expect(index.getFilenames()).toEqual(['valid1.json']);\n      done();\n    });\n  });\n});\ndescribe('Populate Index', () => {\n  const index = new Index();\n  index.saveUploads('valid1.json', valid1);\n  index.saveUploads('valid2.json', valid1);\n  index.createIndex('valid1.json');\n\n  describe('When I Upload a File', () => {\n    it('the index is created once the JSON file has been read', (done) => {\n      expect(typeof index.getIndex('valid1.json')).toEqual('object');\n      done();\n    });\n\n    it('the created index should be an accurate one', (done) => {\n      expect(index.getIndex('valid1.json').alice[0]).toEqual(0);\n      expect(index.getIndex('valid1.json').lord[0]).toEqual(1);\n      expect(index.getIndex('valid1.json').a[1]).toEqual(1);\n      done();\n    });\n\n    it('the created index should be an inverted index', (done) => {\n      let verdict = true;\n      const indexContent = index.indexFile['valid1.json'];\n\n      for (value in indexContent) {\n        if (!Array.isArray(indexContent[value]) || isNaN(indexContent[value][0])) {\n          verdict = false;\n        }\n      }\n      expect(verdict).toEqual(true);\n      done();\n    });\n    it('it should not overwrite the index', (done) => {\n      const indexBefore = index.getIndex('valid1.json');\n      index.createIndex('valid2.json');\n      const indexAfter = index.getIndex('valid1.json');\n      expect(indexBefore).toEqual(indexAfter);\n      done();\n    });\n  });\n});\n\ndescribe('Search Index', () => {\n  const index = new Index();\n  index.saveUploads('valid1.json', valid1);\n  index.createIndex('valid1.json');\n\n  describe('should return the correct result when searched', () => {\n    it('for single word argument', (done) => {\n      const result = index.searchIndex(['valid1.json'], 'alice');\n      expect(result).toEqual({\n        alice: {\n          'valid1.json': [0]\n        }\n      });\n      done();\n    });\n    it('for single word argument with non-alphanumeric', (done) => {\n      const result = index.searchIndex(['valid1.json'], '+alice-=');\n      expect(result).toEqual({\n        alice: {\n          'valid1.json': [0]\n        }\n      });\n      done();\n    });\n\n    it('It should return correct answer for multiple words in one argument', (done) => {\n      const result = index.searchIndex(['valid1.json'], 'alice in');\n      expect(result).toEqual({\n        alice: {\n          'valid1.json': [0]\n        },\n        in: {\n          'valid1.json': [0, 1]\n        }\n      });\n      done();\n    });\n  });\n\n  it(' - The search should not take too long to execute', (done) => {\n    const startTime = performance.now();\n    index.searchIndex(['valid1.json'], 'alice');\n    const endTime = performance.now();\n    expect(endTime - startTime < 5000).toBeTruthy();\n    done();\n  });\n\n  it('should accept a varied number of argument', (done) => {\n    let result = index.searchIndex(['valid1.json'], 'alice in', 'lord town');\n    expect(typeof result).toEqual('object');\n    result = index.searchIndex(['valid1.json'], 'alice in', ['lord', 'town']);\n    expect(typeof result).toEqual('object');\n    result = index.searchIndex(['valid1.json'], 'alice', 'in');\n    expect(result).toEqual({\n      alice: {\n        'valid1.json': [0]\n      },\n      in: {\n        'valid1.json': [0, 1]\n      }\n    });\n    done();\n  });\n\n  it('It should accept an array of argument', (done) => {\n    const result = index.searchIndex(['valid1.json'], ['alice', 'in']);\n    expect(result).toEqual({\n      alice: {\n        'valid1.json': [0]\n      },\n      in: {\n        'valid1.json': [0, 1]\n      }\n    });\n    done();\n  });\n\n\n  it('It should accept mix of array and words as argument', (done) => {\n    result = index.searchIndex(['valid1.json'], 'alice in', ['lord', 'town']);\n    expect(typeof result).toEqual('object');\n    done();\n  });\n\n  describe('Get Index', () => {\n    it('should take the filename of the indexed JSON data', () => {\n      expect(typeof index.getIndex('valid1.json')).toEqual('object');\n    });\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jasmine/spec/inverted-index-test.js\n// module id = 5\n// module chunks = 1","var valid = [{\n  title: 'Alice in Wonderland',\n  text: 'Alice falls into a rabbit hole and enters a world full of imagination.'\n}, {\n  title: 'The Lord of in the Rings: The Fellowship of the Ring.',\n  text: 'An unusual alliance of man, elf, dwarf, wizard and hobbit seek to destroy a powerful ring.'\n}];\n\nmodule.exports = valid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jasmine/spec/dummy-data/file1.js\n// module id = 6\n// module chunks = 1","{\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jasmine/spec/dummy-data/empty.json\n// module id = 7\n// module chunks = 1","[{\n    \"not-title\": \"Black Panther\"\n  },\n  {\n    \"title\": \"Constantine: HellBlazer\",\n    \"text\": \"One man stands between Heaven and Hell. He may be our last hope\"\n  },\n  {\n    \"title\": \"Batman: Year One\",\n    \"text\": \"A rookie BatMan, Fresh from the League of Assasins tries to find his way\"\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jasmine/spec/dummy-data/file5.json\n// module id = 8\n// module chunks = 1","[{\n    \"title\": \"Black Panther\",\n    \"text\": \"\"\n  },\n  {\n    \"title\": \"Constantine: HellBlazer\",\n    \"text\": \"One man stands between Heaven and Hell. He may be our last hope\"\n  },\n  {\n    \"title\": \"Batman: Year One\",\n    \"text\": \"A rookie BatMan, Fresh from the League of Assasins tries to find his way\"\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jasmine/spec/dummy-data/file4.json\n// module id = 9\n// module chunks = 1","[{\n  \"title\": \"Black Panther\",\n  \"text\": 2\n}, {\n  \"title\": \"Constantine: HellBlazer\",\n  \"text\": \"One man stands between Heaven and Hell. He may be our last hope\"\n}, {\n  \"title\": \"Batman: Year One\",\n  \"text\": \"A rookie BatMan, Fresh from the League of Assasins tries to find his way\"\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jasmine/spec/dummy-data/file3.json\n// module id = 10\n// module chunks = 1"],"sourceRoot":""}