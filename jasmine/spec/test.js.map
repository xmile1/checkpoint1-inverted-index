{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///webpack/bootstrap 28327afa450edfbbdbc2?b6c7","webpack:///./src/inverted-index.js?e055","webpack:///./src/utils.js?2ff8","webpack:///./jasmine/spec/inverted-index-test.js","webpack:///./jasmine/spec/dummy-data/file1.js","webpack:///./jasmine/spec/dummy-data/empty.json","webpack:///./jasmine/spec/dummy-data/file5.json","webpack:///./jasmine/spec/dummy-data/file4.json","webpack:///./jasmine/spec/dummy-data/file3.json"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,cAAc,GAAG,aAAa;AACzE;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,SAAS;AACvB,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;;AAEA;AACA;AACA,eAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,QAAQ;AACtB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACxIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,SAAS;AACvB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,QAAQ;AACtB,eAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,EAAC;;;;;;;AC9LD;AACA;AACA;AACA,EAAC;AACD;AACA;AACA,EAAC;;AAED;;;;;;;ACRA;AACA;;;;;;;ACDA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;;;;;;ACVD;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;;;;;;ACXD;AACA;AACA;AACA,EAAC;AACD;AACA;AACA,EAAC;AACD;AACA;AACA,EAAC","file":"test.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"invertedIndex\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"invertedIndex\"] = factory();\n\telse\n\t\troot[\"invertedIndex\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 28327afa450edfbbdbc2","const utils = require('./utils.js');\n\n/**\n * A class for Creating and searching an inverted index\n */\nclass Index {\n\n  /**\n   * [constructor Creates Object variables to hold\n   * 1. [jsonDatabase] Uploaded files\n   * 2. [indexFile] the indexed filenames and their contents\n   * 3. [searchResult] the search results\n   */\n  constructor() {\n    this.jsonDatabase = {};\n    this.indexFile = {};\n    this.searchResult = {};\n  }\n\n  /**\n   * [saveUploads stores the uploaded file(s)]\n   * @param  {string} fileName [filename]\n   * @param  {object} jsonFile [content of uploaded json file]\n   * @return {boolean} [returns true on addition of object to datatbase]\n   */\n  saveUploads(fileName, jsonFile) {\n    if (utils.fileAlreadyExists(fileName, this.jsonDatabase)) {\n      return false;\n    }\n    if (!utils.isFileValid(fileName, jsonFile)) {\n      return false;\n    }\n    if (typeof jsonFile === 'string') {\n      jsonFile = JSON.parse(jsonFile);\n    }\n    this.jsonDatabase[fileName] = [];\n    Object.keys(jsonFile).forEach((keys) => {\n      this.jsonDatabase[fileName].push(jsonFile[keys]);\n    });\n    return true;\n  }\n\n  /**\n   * [getJsonDatabase function to return the saved uploads]\n   * @return {object} [the saved uploads]\n   */\n  getJsonDatabase() {\n    return this.jsonDatabase;\n  }\n\n  /**\n   * [createIndex Creates an index of the words in the received json file]\n   * @param  {string}   filePath [the key(filename) of the json value to index]\n   * @return {array} [an arrray of the indexed file]\n   */\n  createIndex(filePath) {\n    let indexFile = this.indexFile;\n    const jsonDoc = this.jsonDatabase[filePath];\n    let joinedValues = '';\n    let words = [];\n    if (indexFile[filePath]) {\n      return false;\n    }\n    indexFile[filePath] = {};\n    jsonDoc.forEach((element, index) => {\n      joinedValues = utils.cleanString((`${element.title} ${element.text}`));\n      words = new Set(joinedValues.split(' '));\n      words.forEach((word) => {\n        indexFile[filePath][word] = indexFile[filePath][word] || [];\n        indexFile[filePath][word].push(index);\n      });\n    });\n    this.indexFile = indexFile;\n    return indexFile[filePath];\n  }\n\n  /**\n   * [getIndex Gets the index object of the indexed json file]\n   * @param  {string} fileName [the filename(key) of the index needed]\n   * @return {object}          [index of the object]\n   */\n  getIndex(fileName) {\n    return this.indexFile[fileName] || this.indexFile;\n  }\n\n  /**\n   * [searchIndex It searches the already indexed files for particular words]\n   * @param  {string}    fileNames     [description]\n   * @param  {...Array} searchContent [the words to search for]\n   * @return {Array}                  [an array of two elements, an\n   * object with the search term as key and their locations in the\n   * array of the originally uploaded file, an html view of the result]\n   */\n  searchIndex(fileNames, ...searchContent) {\n    let searchResult = {};\n    let Terms = searchContent.join(' ');\n    if (fileNames.length < 1) {\n      fileNames = this.getFileNames();\n    }\n    Terms = utils.cleanString(Terms, /[^a-z0-9\\s,]+/gi);\n    Terms = Terms.split(/[,\\s]/);\n    Terms.forEach((Term) => {\n      searchResult[Term] = {};\n      fileNames.forEach((fileName) => {\n        if (this.indexFile[fileName][Term]) {\n          searchResult[Term][fileName] = this.indexFile[fileName][Term];\n        }\n      });\n    });\n    return searchResult;\n  }\n\n  /**\n   * [getFileNames returns the filenames of all files present in the object]\n   * @return {array} [an array of filenames]\n   */\n  getFileNames() {\n    return Object.keys(this.jsonDatabase);\n  }\n\n  /**\n   * [deleteIndex Deletes an index file from the index object]\n   * @param  {string} fileName [the filename(key) of the data to delete]\n   * @param  {boolean} option   [determines the file to delete]\n   * @return {boolean}  [delete indexFile and/or jsonDatabase]\n   */\n  deleteIndex(fileName, option) {\n    delete this.indexFile[fileName];\n    if (option === true) {\n      delete this.jsonDatabase[fileName];\n      return true;\n    }\n    return false;\n  }\n}\n\nmodule.exports = Index;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/inverted-index.js\n// module id = 3\n// module chunks = 0 1","/* eslint class-methods-use-this: 0*/\n/**\n * Util - An helper class for inverted-index\n */\nclass Util {\n\n  /**\n   * [parseJSON converts sting to a Json object]\n   * @param  {string} jsonFile\n   * @return {object}  [the parsed file or false on error]\n   */\n  parseJSON(jsonFile) {\n    if (typeof jsonFile === 'object') {\n      return jsonFile;\n    }\n    try {\n      return JSON.parse(jsonFile);\n    } catch (err) {\n      return true;\n    }\n  }\n\n  /**\n   * [isFileValid Check if a file is a valid json object based]\n   * @param  {string}  fileName [the filename of the jsonFile]\n   * @param  {object}  jsonFile [the json object to be tested]\n   * @return {Boolean} [returns true if valid else false]\n   */\n  isFileValid(fileName, jsonFile) {\n    if (typeof jsonFile === 'string') {\n      try {\n        jsonFile = JSON.parse(jsonFile);\n      } catch (e) {\n        return false;\n      }\n    }\n    if (jsonFile && jsonFile.length > 0) {\n      const isValidFileStructure = this.checkFileStructure(jsonFile);\n      if (isValidFileStructure) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * [checkFileStructure Checks if fileStructure is valid]\n   * @param  {[object]} jsonFile [json file to be tested]\n   * @return {boolean}          [true if valid and false if invalid]\n   */\n  checkFileStructure(jsonFile) {\n    this.isValidFile = true;\n    jsonFile.forEach((document) => {\n      const validTitle = document.title && document.title.length > 0\n      const validType = typeof document.title === 'string';\n      const validText = document.text && document.text.length > 0\n      const validTextType = typeof document.text === 'string';\n\n      if (!(validTitle && validType && validText && validTextType)) {\n        this.isValidFile = false;\n        return false;\n      }\n    });\n    return this.isValidFile;\n  }\n\n  /**\n   * [cleanString This method returns a clean version of a string\n   * with all unecessary characters striped away]\n   * @param  {string} theString [the string to cleanup]\n   * @param  {[Regex]} theRegex  [the regex to use]\n   * @return {[String]}           [A string Strpped based on the regex]\n   */\n  cleanString(theString, theRegex) {\n    return theString.replace(theRegex, '').toLowerCase() || theString.replace(/[^a-z0-9\\s]+/gi, '').toLowerCase();\n  }\n\n  /**\n   * [Checks if file already exists]\n   * @param  {string} fileName [the filename to search for]\n   * @param  {Object} documentDatabase  [the database to check]\n   * @return {Boolean} true if it exists\n   */\n  fileAlreadyExists(fileName, documentDatabase) {\n    if (documentDatabase[fileName]) {\n      return true;\n    } else {\n      return false\n    }\n  }\n}\n\nmodule.exports = new Util();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = 4\n// module chunks = 0 1","const valid2 = require('./dummy-data/file1.js');\nconst empty = require('./dummy-data/empty.json');\nconst valid1 = require('./dummy-data/file1.js');\nconst invalidStructure = require('./dummy-data/file5.json');\nconst invalidContent = require('./dummy-data/file4.json');\nconst nonString = require('./dummy-data/file3.json');\nvar Index = require('../../src/inverted-index.js');\n\ndescribe('Read Book data', function() {\n  const index = new Index();\n\n  describe('When I upload a JSON file', () => {\n    it('should checks if its a valid JSON array', (done) => {\n      expect(index.saveUploads('invalidStructure.json', invalidStructure)).toBeFalsy();\n      done();\n    });\n    it('should check if the file is empty', (done) => {\n      expect(index.saveUploads('empty.json', empty)).toBeFalsy();\n      done();\n    });\n    it('should check if Its property values are strings', (done) => {\n      expect(index.saveUploads('nonString.json', nonString)).toBeFalsy();\n      done();\n    });\n  });\n\n  describe('When I call the getJsonDatabase function', () => {\n    it('should return the saved content', (done) => {\n      index.saveUploads('valid1.json', valid1);\n      expect(Object.keys(index.getJsonDatabase()).length).toEqual(1);\n      done();\n    });\n  });\n\n  describe('When I call the getFileName function', () => {\n    it('should return the filenames of the saved contents', (done) => {\n      index.saveUploads('valid1.json', valid1);\n      expect(Object.keys(index.getJsonDatabase()).length).toEqual(1);\n      done();\n    });\n  });\n});\n\ndescribe('Populate Index', () => {\n  const index = new Index();\n  index.saveUploads('valid1.json', valid1);\n  index.saveUploads('valid2.json', valid1);\n  index.createIndex('valid1.json');\n\n  describe('When I Upload a File', () => {\n    it('should create an index', (done) => {\n      expect(typeof index.getIndex('valid1.json')).toEqual('object');\n      done();\n    });\n\n    it('should create an accurate index', (done) => {\n      expect(index.getIndex('valid1.json').alice[0]).toEqual(0);\n      expect(index.getIndex('valid1.json').lord[0]).toEqual(1);\n      expect(index.getIndex('valid1.json').a[1]).toEqual(1);\n      done();\n    });\n\n    it('should create an inverted index', (done) => {\n      let verdict = true;\n      const indexContent = index.indexFile['valid1.json'];\n\n      for (value in indexContent) {\n        if (!Array.isArray(indexContent[value]) || isNaN(indexContent[value][0])) {\n          verdict = false;\n        }\n      }\n      expect(verdict).toEqual(true);\n      done();\n    });\n    it('should not overwrite an already created index', (done) => {\n      const indexBefore = index.getIndex('valid1.json');\n      index.createIndex('valid2.json');\n      const indexAfter = index.getIndex('valid1.json');\n      expect(indexBefore).toEqual(indexAfter);\n      done();\n    });\n  });\n});\n\ndescribe('Search Index', () => {\n  const index = new Index();\n  index.saveUploads('valid1.json', valid1);\n  index.createIndex('valid1.json');\n\n  describe('When i pass a single word argument', () => {\n    it('should return the correct index', (done) => {\n      const result = index.searchIndex(['valid1.json'], 'alice');\n      expect(result).toEqual({\n        alice: {\n          'valid1.json': [0]\n        }\n      });\n      done();\n    });\n  });\n\n  describe('When i pass a single word argument with non-alphanumeric', () => {\n    it('should return the correct index', (done) => {\n      const result = index.searchIndex(['valid1.json'], '+alice-=');\n      expect(result).toEqual({\n        alice: {\n          'valid1.json': [0]\n        }\n      });\n      done();\n    });\n  });\n\n  describe('When i pass multiple words in one argument', () => {\n    it('should return the correct index of each word', (done) => {\n      const result = index.searchIndex(['valid1.json'], 'alice in');\n      expect(result).toEqual({\n        alice: {\n          'valid1.json': [0]\n        },\n        in: {\n          'valid1.json': [0, 1]\n        }\n      });\n      done();\n    });\n  });\n\n  describe('When i pass an argument to search for a word', () => {\n    it('should not take too long to execute', (done) => {\n      const startTime = performance.now();\n      index.searchIndex(['valid1.json'], 'alice');\n      const endTime = performance.now();\n      expect(endTime - startTime < 5000).toBeTruthy();\n      done();\n    });\n  });\n\n  describe('When i pass in varied number of argument', () => {\n    it('should return an object with the correct index of each word', (done) => {\n      let result = index.searchIndex(['valid1.json'], 'alice in', 'lord town');\n      expect(typeof result).toEqual('object');\n      result = index.searchIndex(['valid1.json'], 'alice in', ['lord', 'town']);\n      expect(typeof result).toEqual('object');\n      result = index.searchIndex(['valid1.json'], 'enters', 'and');\n      expect(result).toEqual({\n        enters: {\n          'valid1.json': [0]\n        },\n        and: {\n          'valid1.json': [0, 1]\n        }\n      });\n      done();\n    });\n  });\n\n  describe('When i pass in an array as argument', () => {\n    it('should return the correct index of each word', (done) => {\n      const result = index.searchIndex(['valid1.json'], ['full', 'seek']);\n      expect(result).toEqual({\n        full: {\n          'valid1.json': [0]\n        },\n        seek: {\n          'valid1.json': [1]\n        }\n      });\n      done();\n    });\n  });\n\n  describe('When i pass in a mix of array and words as argument', () => {\n    it('should return the correct index of each word', (done) => {\n      result = index.searchIndex(['valid1.json'], 'alice in', ['lord', 'town']);\n      expect(typeof result).toEqual('object');\n      done();\n    });\n  });\n});\n\ndescribe('Get Index', () => {\n  const index = new Index();\n  index.saveUploads('valid1.json', valid1);\n  index.createIndex('valid1.json');\n  describe('When i pass a filename', () => {\n    it('should return an object', () => {\n      expect(typeof index.getIndex('valid1.json')).toEqual('object');\n    });\n  });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jasmine/spec/inverted-index-test.js\n// module id = 6\n// module chunks = 1","var valid = [{\n  title: 'Alice in Wonderland',\n  text: 'Alice falls into a rabbit hole and enters a world full of imagination.'\n}, {\n  title: 'The Lord of in the Rings: The Fellowship of the Ring.',\n  text: 'An unusual alliance of man, elf, dwarf, wizard and hobbit seek to destroy a powerful ring.'\n}];\n\nmodule.exports = valid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jasmine/spec/dummy-data/file1.js\n// module id = 7\n// module chunks = 1","{\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jasmine/spec/dummy-data/empty.json\n// module id = 8\n// module chunks = 1","[{\n    \"not-title\": \"Black Panther\"\n  },\n  {\n    \"title\": \"Constantine: HellBlazer\",\n    \"text\": \"One man stands between Heaven and Hell. He may be our last hope\"\n  },\n  {\n    \"title\": \"Batman: Year One\",\n    \"text\": \"A rookie BatMan, Fresh from the League of Assasins tries to find his way\"\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jasmine/spec/dummy-data/file5.json\n// module id = 9\n// module chunks = 1","[{\n    \"title\": \"Black Panther\",\n    \"text\": \"\"\n  },\n  {\n    \"title\": \"Constantine: HellBlazer\",\n    \"text\": \"One man stands between Heaven and Hell. He may be our last hope\"\n  },\n  {\n    \"title\": \"Batman: Year One\",\n    \"text\": \"A rookie BatMan, Fresh from the League of Assasins tries to find his way\"\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jasmine/spec/dummy-data/file4.json\n// module id = 10\n// module chunks = 1","[{\n  \"title\": \"Black Panther\",\n  \"text\": 2\n}, {\n  \"title\": \"Constantine: HellBlazer\",\n  \"text\": \"One man stands between Heaven and Hell. He may be our last hope\"\n}, {\n  \"title\": \"Batman: Year One\",\n  \"text\": \"A rookie BatMan, Fresh from the League of Assasins tries to find his way\"\n}]\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./jasmine/spec/dummy-data/file3.json\n// module id = 11\n// module chunks = 1"],"sourceRoot":""}